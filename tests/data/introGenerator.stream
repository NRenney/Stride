	use PufferFish version 0.0

	# Declare an oscillator
	# Connect its output to audio output 1 using a stream operator
	oscillator (
		type: 		'sine'
		amplitude: 	1.0
		frequency: 	440.0
		phase: 		0.0 
	) 
	>> AudioOut[1];
	
	use PufferFish version 0.0
	
	constant Frequency {
		value:	220.0
		meta:	none
	}

	oscillator (
		type: 		'sine'
		amplitude: 	0.5
		frequency: 	Frequency
		phase: 		0.0 
	)
	+ oscillator (
		type: 		'sine'
		amplitude: 	0.4
		frequency: 	Frequency * 1.5
		phase: 		0.0 
	)
	>> [ AudioOut[1], AudioOut[2] ];

	use PufferFish version 0.0
	
	constant Frequency {
		input:	220.0
		meta:	none
	}

	oscillator (
		type: 		[ 'sine', 'sine' ]
		amplitude: 	[ 0.5, 0.4 ]
		frequency: 	[ Frequency, Frequency * 1.5 ]
		phase: 		[ 0.0, 0.0 ] 
	)
	>> [ AudioOut[1], AudioOut[2] ];
	
	use PufferFish version 0.0
	
	constant Frequency {
		input:	220.0
		meta:	none
	}
	
	signal SineWaveUnision {
		rate:	AudioRate
		meta:	'Sine wave oscillator with base frequency.'
	}
	
	signal SineWaveFifth {
		rate:	AudioRate
		meta:	'Sine wave oscillator with relative frequency.'
	}
	
	oscillator (
		type: 		'sine'
		amplitude: 	1.0
		frequency: 	Frequency
		phase: 		0.0 
	)	
	>> SineWaveUnision;
	
	oscillator (
		type: 		'sine'
		amplitude: 	1.0
		frequency: 	Frequency * 1.5
		phase: 		0.0 
	)
	>> SineWaveFifth;
	
	mix ( 
		signalList:	[ SineWaveUnision, SineWaveFifth ]
		biasList: 	0.0
		gainList: 	[ 0.5, 0.4 ]
	) 
	>> [ AudioOut[1], AudioOut[2] ];
	
	constant Range {
		value: 	0.75
		meta:	'Panning limits.'
	}

	control PanPosition {
		mapping:	{
			mode:		'linear'
			default:	0.0
			minimum:	-Range
			maximum:	Range
			increment:	0.01
			rounding:	'truncate'
			meta:		none
		}
		rate:	1024
		meta:	'Pan position control'
	}
	
	oscillator (
		type: 		'triangle'
		amplitude: 	1.0
		frequency: 	2.0
		phase: 		0.0 
	)
	>> PanPosition;
	
	mix ( 
		signalList:	[ SineWaveUnision, SineWaveFifth ]
		biasList: 	0.0
		gainList: 	[ 0.5, 0.4 ]
	)
	>> pan (
		position:	PanPosition
		bypass:		off	
	)
	>> [ AudioOut[1], AudioOut[2] ];	

	use PufferFish version 0.0
	
	signal ThreeSineWaves {
		rate:	AudioRate
		meta:	'Three sine wave oscillators.'
	}
	
	oscillator (
		type: 		'sine'
		amplitude: 	[ 1.0, 0.66, 0.33 ]
		frequency: 	[ 220.0, 440.0, 880.0 ]
		phase: 		0.0 
	)
	>> ThreeSineWaves;
	
	# The amplitude of 'ThreeSineWaves' is 2.0
	# The amplitude should be limited to 1.0 to avoid clipping at the DAC.
	ThreeSineWaves * 0.5 >> AudioOut[1];
	
use PufferFish version 0.0
	
	# Declare an osc block
	osc OSC {
		hostIP:		'192.168.1.1'
		incomingPort:	8000
		outgoingPort:	9000
		meta:			none
	}
	
	# Declare a map for the fundamental frequency
	map FrequencyMap {
		mode:		'clip'
		default:	110.0
		minimum:	22.5
		maximum:	7040.0
		increment:	0.01
		rounding:	'floor'
		meta:		'Limit range of incoming values for the frequency over osc.'
	}
	
	# Declare a control block
	# The rate is set to none since OSC messages are asynchronous
	control Fundamental {
		mapping:	FrequencyMap
		rate:		none
		meta:		'Fundamental frequency change over OSC.'  
	}
	
	# Connect the 'OSC' block to the 'Fundamental' control block
	OSC >> Fundamental;
	
	signal ThreeSineWave {
		rate:	AudioRate
		meta:	'Three sine wave oscillators with controllable frequencies.'
	}

	oscillator (
		type: 		'sine'
		amplitude: 	[ 1.0, 0.66, 0.33 ]
		frequency: 	[ 1.0 , 2.0, 3.0 ] * Fundamental
		phase: 		0.0 
	) 
	* 0.5
	>> ThreeSineWave;

	ThreeSineWave >> AudioOut[1];
	
	constant Fundamental {
		value: 55.0
		meta: 'Fundamental frequency.'
	}

	generator ThreeHarmonicPartials {
		aliasList:	[ 'fundamental', 'level' ]
		propertyBlocks:	[ 
					constant FundamentalFrequency { 
						value:	440.0
						meta:	'Default frequency.'
					}, 
					constant Level { 
						value:	0.5
						meta:	'Default level.' 
					}
				]
		internalBlocks:	none
		process:	oscillator (
					type: 		'sine'
					amplitude: 	[ 1.0, 0.66, 0.33 ]
					frequency: 	[ 1.0 , 2.0, 3.0 ] * FundamentalFrequency  
					phase: 		0.0 
				) 
				* Level
		meta:		'Three harmonic partials with fundamental frequency and level control.'	
	}
	
	signal HarmonicPartialsPlusFifths {
		rate:	AudioRate
		meta:	'Sum of three harmonic partials and their fifths'
	}
	
	ThreeHarmonicPartials (
		fundamental:	[ 1.0, 1.5 ] * Fundamental
		level:		[ 0.45, 0.35 ]
	)
	>> HarmonicPartialsPlusFifths;
	
	sequence Frequencies {
		valueList:	[ 220.0, 261.63, 329.63, 440.0 ]
		mode:		'down'
		repeat:		on
		reset:		none
		meta:		'Minor A chord notes.'
	}
	
	signal Pulse {
		rate:	512
		meta:	'Signal used for trigger generation.'
	}
	
	pulse (
		dutyCycle: 	0.25
		amplitude: 	1.0
		frequency: 	3.0
		phase: 		0.0 
	)
	>> Pulse
	>> signal2switch ( 
		threshold:	0.5
		edge:		'rising'
		invert:		off
	)
	>> Frequencies;
	
	oscillator (
		type: 		'saw'
		amplitude: 	1.0
		frequency: 	Frequencies
		phase: 		0.0 
	)	
	>> AudioOut[1];
	

	sequence Frequencies {
		valueList:	[ 220.0, 261.63, 329.63, 440.0 ]
		mode:		'ping-pong'
		repeat:		on
		reset:		none
		meta:		'Minor A chord notes.'
	}

	DigitalIn[1] >> Frequencies;
	
	oscillator (
		type: 		'saw'
		amplitude: 	1.0
		frequency: 	Frequencies
		phase: 		0.0 
	)	
	>> AudioOut[1];


	sequence Frequencies {
		valueList:	[ 220.0, 261.63, 329.63, 440.0 ]
		mode:		'ping-pong'
		repeat:		on
		reset:		none
		meta:		'Minor A chord notes.'
	}

	DigitalIn[1] >> onTransition () >> Frequencies;
	
	oscillator (
		type: 		'saw'
		amplitude: 	1.0
		frequency: 	Frequencies
		phase: 		0.0 
	)	
	>> AudioOut[1];


	sequence Frequencies {
		valueList:	[ 220.0, 261.63, 329.63, 440.0 ]
		mode:		'random'
		repeat:		on
		reset:		none
		meta:		'Minor A chord notes.'
	}		
	
	AnalogIn[1] 
	>> control2switch ( 
		threshold:	5.0
		edge:		'both'
		invert:		off 
	) 
	>> Frequencies;
	
	oscillator (
		type: 		'square'
		amplitude: 	1.0
		frequency: 	Frequencies
		phase: 		0.0 
	)	
	>> AudioOut[1];
	

	constant OscType [5] {
		value:	[ 'Sine' , 'Saw', 'Sine', 'Saw', 'Triangle' ]
		meta: 	none
	}

	control OscTypeSelect {
		mapping:	{
			type: 		'linear'
			default:	3
			minimum:	1
			maximum:	6
			increment:	1
			rounding:	'floor'
			meta:		none
		}
		rate:	2048
		meta:	none
	}
		
	AnalogIn[1] >> OscTypeSelect;
	
	oscillator (
		type: 		OscType[OscTypeSelect]
		amplitude: 	1.0
		frequency: 	440.0
		phase: 		0.0 
	)
	>> AudioOut[1];


	constant Size {
		value:	5
		meta:	'Size of OscType.'
	}

	constant OscType [Size] {
		value:	[ 'Sine' , 'Saw', 'Sine', 'Saw', 'Triangle' ]
		meta: 	none
	}
	
	control Index {
		mapping:	{
			type: 'linear'
			default: 3
			minimum: 1
			maximum: Size + 1
			increment: 1
			rounding: 'floor'
			meta: 'Map values to integers in the rage of 1 to Size.'
		}
		rate:	2048
		meta:	'Translate analog input 1 to an integer through a linear mapping.'
	}
	
	control OscTypeSelect {
		mapping:	{
			type:		'clip'
			default: 	3
			minimum:	1
			maximum:	5
			increment:	1
			rounding:	'truncate' 
			meta: none
		}
		rate:	none
		meta:	'Asynchronous control to index OscType' 
	}
	
	AnalogIn[1] >> Index >> onChange() >> OscTypeSelect;
	
	oscillator (
		type: 		OscType[OscTypeSelect]
		amplitude: 	1.0
		frequency: 	440.0
		phase: 		0.0 
	)
	>> AudioOut[1];
	

	signal MyOsc {
		rate:	AudioRate
		meta:	none
	}

	constant Size {
		value:	256
		meta:	none
	}

	constant Values [Size] {
		value:  [ 0.0, 0.49, 0.99, 0.49, 0.0 ]
		meta: 	none
	}

	switch AsynchGate {
		default: 	off
		meta:		none
	}

	sequence Frequencies {
		valueList:      [ 220.0, 261.63, 329.63, 440.0 ]
		mode:           'up'
		repeat:			on
		reset:          none
		meta:           'Minor A chord notes.'
	}

	control Index {
		mapping:        {
			type:		'linear'
			default:	128
			minimum:	1
			maximum:	Size + 1 
			increment:	1
			rounding:	'floor'
			meta:		none
		}
		rate:		256
		meta:		none
	}
	
	AnalogIn[1] 
	>> Index 
	>> onChange() 
	>> control2switch ( 
		threshold:	0.1
		edge:		'rising'
		invert:		off
	)
	>> AsynchGate 
	>> Frequencies;

	oscillator (
		type:		'Sine'
		amplitude:	Values[Index]
		frequency:	Frequencies
		phase:		0.0
	)
	>> MyOsc;